* 为什么组件的data选项只接收`function`,[详细](https://cn.vuejs.org/v2/api/#data)
> 组件一般会复用，对象是引用类型，作为参数（值赋值）是浅拷贝，所有的赋值对象都指向同一地址，一个对象改变其它都会改变。但是用function来返回一个对象（每次复用都会创建一个新对象）来保持每个组件的data都是独立的。
* 路由钩子与其它生命周期钩子的执行顺序，下面内容转自[曾广营](https://segmentfault.com/a/1190000008879966)
> 首先看下vue中有哪些生命周期钩子（钩子简单来讲就是像switch条件语句的case,作为一个入口）
1. 根组件实例：8个 (beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed)
2. 组件实例：8个 (beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed)
3. 全局路由钩子：2个 (beforeEach、afterEach)
4. 组件路由钩子：3个 (beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave)
5. 指令的周期： 5个 (bind、inserted、update、componentUpdated、unbind)
6. beforeRouteEnter的next所对应的周期
7. nextTick所对应的周期beforeCreate
**执行顺序**
1. 路由勾子 (beforeEach、beforeRouteEnter、afterEach)
2. 根组件 (beforeCreate、created、beforeMount)
3. 组件 (beforeCreate、created、beforeMount)
4. 指令 (bind、inserted)
5. 组件 mounted
6. 根组件 mounted
7. beforeRouteEnter的next的回调
8. nextTick
**注意**
1. 路由勾子执行周期在根实例的渲染之前。
具体的顺序 router.beforeEach > beforeRouteEnter > router.afterEach
2. 在进行路由拦截的时候要避免使用实例内部的方法或属性。
当拦截的程序，写在了根实例的方法上了，到beforeEach去调用。
结果导致整个拦截的周期，推迟到实例渲染的之后。因此对于一些路由组件的beforeRouteEnter里的请求并无法拦截，页面看上去好像已经拦截下来了。实际上请求依然发了出去，beforeRouteEnter内的函数依然执行了。
3. 指令的绑定在组件mounted之前，组件的beforeMount之后
4. beforeRouteEnter的next勾子
beforeRouteEnter的执行顺序是如此靠前，而其中next的回调勾子的函数，执行则非常靠后，在mounted之后！！我们通常是在beforeRouteEnter中加载一些首屏用数据，待数据收到后，再调用next勾子，通过回调的参数vm将数据绑定到实例上。
因此，请注意next的勾子是非常靠后的。
5. nextTick
越早注册的nextTick触发越早

* 利用axios一次请求多个数据，如何确保得到全部数据才渲染
>避免一个一个接收响应数据，利用axios.all或者Promise.all来进行所有请求的发送，这样一次性得到所有的响应数据
例子如下：
```javascript
function getUrl(article) {
  let url = new Array(article.length)
  for (let index = 0; index < article.length; index++) {
    url[index] = 'static/article/' + article[index].name
  }
  return url.map(function (value) {
    return axios.get(value).then(res => {
      return Promise.resolve(res.data)
    })
  })
}
function getArticle(article) {
  let result = getUrl(article)
  return Promise.all(result).then(results => {
    return results.map(function (value) {
      return markdown(value)
    })
  })
}
```
* 动态路由参数改变时要在watch钩子中做出相应的更新
```javascript
watch: {
   '$route' (to, from) {
      this.fetchData()
      this.show()
   }
}
```

> * 整理知识，学习笔记
> * 发布日记，杂文，所见所想
> * 撰写发布技术文稿（代码支持）
> * 撰写发布学术论文（LaTeX 公式支持）